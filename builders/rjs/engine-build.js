
// Generated by CoffeeScript 1.7.1
(function() {
  define('utils/properties.manager.js',[], function() {
    return emo$.Engine.Utils.PropertiesManager = (function() {
      var properties;

      properties = null;

      function PropertiesManager(fileName) {
        $.ajax({
          url: fileName,
          async: false,
          crossDomain: true,
          success: function(data) {
            return properties = emo$.Libs.x2js.xml2json(data).properties.entry;
          },
          error: function(e) {
            return console.log(e);
          }
        });
      }

      PropertiesManager.prototype.getProperty = function(key) {
        var prop, _i, _len;
        for (_i = 0, _len = properties.length; _i < _len; _i++) {
          prop = properties[_i];
          if (prop['_key'] === key) {
            return prop['__text'];
          }
        }
      };

      PropertiesManager.prototype.getIntArrayProperty = function(key) {
        var line, string, strings, values, _i, _len;
        line = this.getProperty(key);
        strings = line.split(', ');
        values = [];
        for (_i = 0, _len = strings.length; _i < _len; _i++) {
          string = strings[_i];
          values.push(parseInt(string, 16));
        }
        return values;
      };

      return PropertiesManager;

    })();
  });

}).call(this);

//# sourceMappingURL=properties.manager.map
;
// Generated by CoffeeScript 1.7.1
(function() {
  define('utils/file.reader.js',[], function() {
    return emo$.Engine.Utils.FileReader = (function() {
      function FileReader() {}

      FileReader.readFile = function(fileName) {
        var file;
        file = null;
        $.ajax({
          url: fileName,
          async: false,
          crossDomain: true,
          success: function(data) {
            return file = data;
          },
          error: function(e) {
            return console.log(e);
          }
        });
        return file;
      };

      FileReader.parseLine = function(line) {
        var ret;
        return ret = null;
      };

      return FileReader;

    })();
  });

}).call(this);

//# sourceMappingURL=file.reader.map
;
// Generated by CoffeeScript 1.7.1
(function() {
  emo$.Engine.Utils = (function() {
    function Utils() {}

    return Utils;

  })();

  define('utils/_utils_.js',['../_engine_.js', './properties.manager.js', './file.reader.js']);

}).call(this);

//# sourceMappingURL=_utils_.map
;
// Generated by CoffeeScript 1.7.1
(function() {
  define('emotion/helpers/heuristics.js',[], function() {
    return emo$.Engine.Emotion.Helpers.Heuristics = (function() {
      var countChars, isCapsLock, isIntensityModifier;

      function Heuristics() {}

      isCapsLock = function(word) {
        var x, _i, _ref;
        for (x = _i = 1, _ref = word.length; _i < _ref; x = _i += 1) {
          if (word[x] === word[x].toLowerCase()) {
            return false;
          }
        }
        return true;
      };

      isIntensityModifier = function(word) {
        return emo$.Engine.Emotion.Helpers.Lexical.getInstance().isIntensityModifier(word);
      };

      countChars = function(arg, c) {
        var count, i, _i, _ref;
        count = 0;
        for (i = _i = 1, _ref = arg.length; _i < _ref; i = _i += 1) {
          if (arg[i] === c) {
            count++;
          }
        }
        return count;
      };

      Heuristics.computeEmoticonCoefForSentence = function(sentence) {
        var emot, emoticons, value, _fn, _i, _len;
        emoticons = emo$.Engine.Emotion.Helpers.Lexical.getInstance().getEmoticonWords(sentence);
        value = 1.0;
        _fn = function(emot) {
          var emotWord;
          emotWord = emot.getWord();
          return value *= 1.0 + (0.2 * countChars(sentence, emotWord.charAt(emotWord.length - 1)));
        };
        for (_i = 0, _len = emoticons.length; _i < _len; _i++) {
          emot = emoticons[_i];
          _fn(emot);
        }
        return value;
      };

      Heuristics.computeEmoticonCoef = function(word, emoticon) {
        var emotiveWord;
        if (emoticon.startsWithEmoticon()) {
          emotiveWord = emoticon.getWord();
          return 1.0 + (0.2 * countChars(word, emotiveWord.charAt(emotiveWord.length - 1)));
        } else {
          return 1.0;
        }
      };

      Heuristics.computeCapsLockQoef = function(word) {
        if (isCapsLock(word)) {
          return 1.5;
        } else {
          return 1.0;
        }
      };

      Heuristics.hasNegation = function(sentence) {
        return emo$.Engine.Emotion.Helpers.Lexical.getInstance().hasNegation(sentence);
      };

      Heuristics.computeModifier = function(word) {
        if (isIntensityModifier(word)) {
          return 1.5;
        } else {
          return 1.0;
        }
      };

      Heuristics.computeCapsLockQoef = function(word) {
        if (isCapsLock(word)) {
          return 1.5;
        } else {
          return 1.0;
        }
      };

      Heuristics.computeExclaminationQoef = function(text) {
        return 1.0 + (0.2 * countChars(text, '!'));
      };

      return Heuristics;

    })();
  });

}).call(this);

//# sourceMappingURL=heuristics.map
;
// Generated by CoffeeScript 1.7.1
(function() {
  define('emotion/helpers/lexical.js',[], function() {
    return emo$.Engine.Emotion.Helpers.Lexical = (function() {
      var affectWords, dataServerAddr, emoticons, fileNameEmoticons, fileNameLexicon, fileNameProperties, instance, intensityModifiers, negations, normalisator;

      instance = null;

      dataServerAddr = 'http://localhost:8899';

      fileNameLexicon = dataServerAddr + '/lex/synesketch_lexicon.txt';

      fileNameEmoticons = dataServerAddr + '/lex/synesketch_lexicon_emoticons.txt';

      fileNameProperties = dataServerAddr + '/lex/keywords.xml';

      affectWords = null;

      emoticons = null;

      negations = null;

      intensityModifiers = null;

      normalisator = 0.75;

      function Lexical() {
        var pm;
        emoticons = [];
        pm = new emo$.Engine.Utils.PropertiesManager(fileNameProperties);
        negations = emo$.Engine.Emotion.Helpers.Parsing.splitWords(pm.getProperty('negations'), ', ');
        intensityModifiers = emo$.Engine.Emotion.Helpers.Parsing.splitWords(pm.getProperty("intensity.modifiers"), ", ");
        affectWords = this.parseLexiconFile(fileNameLexicon);
        emoticons = this.parseLexiconFile(fileNameEmoticons);
      }

      Lexical.getInstance = function() {
        if (instance === null) {
          instance = new Lexical();
        }
        return instance;
      };

      Lexical.prototype.parseLexiconFile = function(fileName) {
        var file, line, lines, record, wordList, _i, _len;
        wordList = [];
        file = emo$.Engine.Utils.FileReader.readFile(fileName);
        lines = file.split('\n');
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          record = this.parseLine(line);
          wordList.push(record);
        }
        return wordList;
      };

      Lexical.prototype.parseLine = function(line) {
        value;
        var angerWeight, disgustWeight, fearWeight, generalWeight, happinessWeight, sadnessWeight, surpriseWeight, text, value, word;
        text = line.split(' ');
        word = text[0];
        generalWeight = parseFloat(text[1]);
        happinessWeight = parseFloat(text[2]);
        sadnessWeight = parseFloat(text[3]);
        angerWeight = parseFloat(text[4]);
        fearWeight = parseFloat(text[5]);
        disgustWeight = parseFloat(text[6]);
        surpriseWeight = parseFloat(text[7]);
        value = new emo$.Engine.Emotion.AffectWord(word, generalWeight, happinessWeight, sadnessWeight, angerWeight, fearWeight, disgustWeight, surpriseWeight, normalisator);
        return value;
      };

      Lexical.prototype.getAffectWord = function(word) {
        var affectWord, _i, _len;
        for (_i = 0, _len = affectWords.length; _i < _len; _i++) {
          affectWord = affectWords[_i];
          if (affectWord.getWord() === word) {
            return affectWord.clone();
          }
        }
        return null;
      };

      Lexical.prototype.getEmoticonAffectWord = function(word) {
        var affectWordEmoticon, _fn, _fn1, _i, _j, _len, _len1;
        _fn = function(affectWordEmoticon) {
          if (affectWordEmoticon.getWord() === word) {
            return affectWordEmoticon.clone();
          }
        };
        for (_i = 0, _len = emoticons.length; _i < _len; _i++) {
          affectWordEmoticon = emoticons[_i];
          _fn(affectWordEmoticon);
        }
        _fn1 = function(affectWordEmoticon) {
          var emoticon;
          emoticon = affectWordEmoticon.getWord();
          if (emo$.Engine.Emotion.Helpers.Parsing.containsFirst(word, emoticon)) {
            affectWordEmoticon.setStartsWithEmoticon(true);
            return affectWordEmoticon.clone();
          }
        };
        for (_j = 0, _len1 = emoticons.length; _j < _len1; _j++) {
          affectWordEmoticon = emoticons[_j];
          _fn1(affectWordEmoticon);
        }
        return null;
      };

      Lexical.prototype.getEmoticonWords = function(sentence) {
        var emoticon, value, _fn, _i, _len;
        value = [];
        _fn = function(emoticon) {
          var emoticonWord;
          emoticonWord = emoticon.getWord();
          if (sentence.contains(emoticonWord)) {
            emoticon.setStartsWithEmoticon(true);
            return value.push(emoticon);
          }
        };
        for (_i = 0, _len = emoticons.length; _i < _len; _i++) {
          emoticon = emoticons[_i];
          _fn(emoticon);
        }
        return value;
      };

      Lexical.prototype.getAffectWords = function() {
        return affectWords;
      };

      Lexical.prototype.isNegation = function(word) {
        var ret;
        return ret = negations.indexOf(word) > -1;
      };

      Lexical.prototype.hasNegation = function(sentence) {
        var negation, _i, _len;
        for (_i = 0, _len = negations.length; _i < _len; _i++) {
          negation = negations[_i];
          if (sentence.indexOf(negation) > -1) {
            return true;
          }
        }
        return false;
      };

      Lexical.prototype.isIntensityModifier = function(word) {
        var ret;
        return ret = intensityModifiers.indexOf(word) > -1;
      };

      return Lexical;

    })();
  });

}).call(this);

//# sourceMappingURL=lexical.map
;
// Generated by CoffeeScript 1.7.1
(function() {
  define('emotion/helpers/parsing.js',[], function() {
    return emo$.Engine.Emotion.Helpers.Parsing = (function() {
      function Parsing() {}

      Parsing.parseSentences = function(text) {
        var value;
        value = [];
        value.push(text);
        return value;
      };

      Parsing.parseWords = function(text) {
        var value;
        value = [];
        value.push(text);
        return value;

        /*value = []
        boundary = BreakIterator.getWordInstance()
        boundary.setText(text)
        start = boundary.first()
        for int end = boundary.next(); end != BreakIterator.DONE; start = end, end = boundary.next()
          word = text.substring(start, end)
          value.push(word)
        return value
         */
      };

      Parsing.splitWords = function(text, splitter) {
        return text.split(splitter);
      };

      Parsing.containsFirst = function(container, containee) {
        var x, _i, _ref;
        if (container.length > containee.length) {
          for (x = _i = 1, _ref = containee.length; _i < _ref; x = _i += 1) {
            if (!(containee.charAt(x) === container.charAt(x))) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      };

      return Parsing;

    })();
  });

}).call(this);

//# sourceMappingURL=parsing.map
;
// Generated by CoffeeScript 1.7.1
(function() {
  emo$.Engine.Emotion.Helpers = (function() {
    function Helpers() {}

    return Helpers;

  })();

  define('emotion/helpers/_helpers_.js',['./heuristics.js', './lexical.js', './parsing.js'], function() {});

}).call(this);

//# sourceMappingURL=_helpers_.map
;
// Generated by CoffeeScript 1.7.1
(function() {
  define('emotion/affect.word.js',[], function() {
    return emo$.Engine.Emotion.AffectWord = (function() {
      AffectWord.prototype.word = null;

      AffectWord.prototype.generalWeight = 0.0;

      AffectWord.prototype.generalValence = 0.0;

      AffectWord.prototype.happinessWeight = 0.0;

      AffectWord.prototype.sadnessWeight = 0.0;

      AffectWord.prototype.angerWeight = 0.0;

      AffectWord.prototype.fearWeight = 0.0;

      AffectWord.prototype.disgustWeight = 0.0;

      AffectWord.prototype.surpriseWeight = 0.0;

      AffectWord.prototype.startsWithEmoticon = false;

      function AffectWord(word, generalWeight, happinessWeight, sadnessWeight, angerWeight, fearWeight, disgustWeight, surpriseWeight, quoficient) {
        this.word = word;
        this.generalWeight = generalWeight;
        this.happinessWeight = happinessWeight;
        this.sadnessWeight = sadnessWeight;
        this.angerWeight = angerWeight;
        this.fearWeight = fearWeight;
        this.disgustWeight = disgustWeight;
        this.surpriseWeight = surpriseWeight;
        this.quoficient = quoficient;
        if (quoficient) {
          this.generalWeight = this.generalWeight * quoficient;
          this.happinessWeight = this.happinessWeight * quoficient;
          this.sadnessWeight = this.sadnessWeight * quoficient;
          this.angerWeight = this.angerWeight * quoficient;
          this.fearWeight = this.fearWeight * quoficient;
          this.disgustWeight = this.disgustWeight * quoficient;
          this.surpriseWeight = this.surpriseWeight * quoficient;
        }
        this.generalValence = this.getValenceSum();
      }

      AffectWord.prototype.adjustWeights = function(quoficient) {
        this.generalWeight = this.generalWeight * quoficient;
        this.happinessWeight = this.happinessWeight * quoficient;
        this.sadnessWeight = this.sadnessWeight * quoficient;
        this.angerWeight = this.angerWeight * quoficient;
        this.fearWeight = this.fearWeight * quoficient;
        this.disgustWeight = this.disgustWeight * quoficient;
        this.surpriseWeight = this.surpriseWeight * quoficient;
        return this.normalise();
      };

      AffectWord.prototype.normalise = function() {
        if (this.generalWeight > 1) {
          this.generalWeight = 1.0;
        }
        if (this.happinessWeight > 1) {
          this.happinessWeight = 1.0;
        }
        if (this.sadnessWeight > 1) {
          this.sadnessWeight = 1.0;
        }
        if (this.angerWeight > 1) {
          this.angerWeight = 1.0;
        }
        if (this.fearWeight > 1) {
          this.fearWeight = 1.0;
        }
        if (this.disgustWeight > 1) {
          this.disgustWeight = 1.0;
        }
        if (this.surpriseWeight > 1) {
          return this.surpriseWeight = 1.0;
        }
      };

      AffectWord.prototype.flipValence = function() {
        var temp;
        this.generalValence = -this.generalValence;
        temp = this.happinessWeight;
        this.happinessWeight = Math.max(Math.max(this.sadnessWeight, this.angerWeight), Math.max(this.fearWeight, this.disgustWeight));
        this.sadnessWeight = temp;
        this.angerWeight = temp / 2;
        this.fearWeight = temp / 2;
        return this.disgustWeight = temp / 2;
      };

      AffectWord.prototype.clone = function() {
        var value;
        value = new AffectWord(this.word, this.generalWeight, this.happinessWeight, this.sadnessWeight, this.angerWeight, this.fearWeight, this.disgustWeight, this.surpriseWeight);
        value.setStartsWithEmoticon(this.startsWithEmoticon);
        return value;
      };

      AffectWord.prototype.getStartsWithEmoticon = function() {
        return this.startsWithEmoticon;
      };

      AffectWord.prototype.setStartsWithEmoticon = function(startsWithEmoticon) {
        return this.startsWithEmoticon = startsWithEmoticon;
      };

      AffectWord.prototype.getAngerWeight = function() {
        return this.angerWeight;
      };

      AffectWord.prototype.setAngerWeight = function(angerWeight) {
        return this.angerWeight = angerWeight;
      };

      AffectWord.prototype.getDisgustWeight = function() {
        return this.disgustWeight;
      };

      AffectWord.prototype.setDisgustWeight = function(disgustWeight) {
        return this.disgustWeight = disgustWeight;
      };

      AffectWord.prototype.getFearWeight = function() {
        return this.fearWeight;
      };

      AffectWord.prototype.setFearWeight = function(fearWeight) {
        return this.fearWeight = fearWeight;
      };

      AffectWord.prototype.getHappinessWeight = function() {
        return this.happinessWeight;
      };

      AffectWord.prototype.setHappinessWeight = function(happinessWeight) {
        return this.happinessWeight = happinessWeight;
      };

      AffectWord.prototype.getSadnessWeight = function() {
        return this.sadnessWeight;
      };

      AffectWord.prototype.setSadnessWeight = function(sadnessWeight) {
        return this.sadnessWeight = sadnessWeight;
      };

      AffectWord.prototype.getSurpriseWeight = function() {
        return this.surpriseWeight;
      };

      AffectWord.prototype.setSurpriseWeight = function(surpriseWeight) {
        return this.surpriseWeight = surpriseWeight;
      };

      AffectWord.prototype.getWord = function() {
        return this.word;
      };

      AffectWord.prototype.getGeneralWeight = function() {
        return this.generalWeight;
      };

      AffectWord.prototype.setGeneralWeight = function(generalWeight) {
        return this.generalWeight = generalWeight;
      };

      AffectWord.prototype.getGeneralValence = function() {
        return this.generalValence;
      };

      AffectWord.prototype.setGeneralValence = function(generalValence) {
        return this.generalValence = generalValence;
      };

      AffectWord.prototype.isZeroEkman = function() {
        if (this.getWeightSum() === 0) {
          return true;
        } else {
          return false;
        }
      };

      AffectWord.prototype.toString = function() {
        var ret;
        return ret = this.word + ' ' + this.generalWeight + ' ' + this.happinessWeight + ' ' + this.sadnessWeight + ' ' + this.angerWeight + ' ' + this.fearWeight + ' ' + this.disgustWeight + ' ' + this.surpriseWeight;
      };

      AffectWord.prototype.getValenceSum = function() {
        var ret;
        return ret = this.happinessWeight - this.sadnessWeight - this.angerWeight - this.fearWeight - this.disgustWeight;
      };

      AffectWord.prototype.getWeightSum = function() {
        var ret;
        return ret = this.happinessWeight + this.sadnessWeight + this.angerWeight + this.fearWeight + this.disgustWeight + this.surpriseWeight;
      };

      return AffectWord;

    })();
  });

}).call(this);

//# sourceMappingURL=affect.word.map
;
// Generated by CoffeeScript 1.7.1
(function() {
  define('emotion/emotion.js',[], function() {
    emo$.Engine.Emotion.Emotion = (function() {
      function Emotion(weight, type) {
        this.weight = weight;
        this.type = type;
      }

      Emotion.prototype.compareTo = function(arg0) {
        var value;
        value = 100 * ((arg0.weight != null) - this.weight);
        if (value === 0) {
          return 1;
        }
        return value;
      };

      Emotion.prototype.getType = function() {
        return this.type;
      };

      Emotion.prototype.setType = function(type) {
        this.type = type;
      };

      Emotion.prototype.getWeight = function() {
        return this.weight;
      };

      Emotion.prototype.setWeight = function(weight) {
        this.weight = weight;
      };

      Emotion.prototype.toString = function() {
        return "Type number: " + this.type + ", weight: " + this.weight;
      };

      return Emotion;

    })();
    emo$.Engine.Emotion.Emotion.NEUTRAL = -1;
    emo$.Engine.Emotion.Emotion.HAPPINESS = 0;
    emo$.Engine.Emotion.Emotion.SADNESS = 1;
    emo$.Engine.Emotion.Emotion.FEAR = 2;
    emo$.Engine.Emotion.Emotion.ANGER = 3;
    emo$.Engine.Emotion.Emotion.DISGUST = 4;
    return emo$.Engine.Emotion.Emotion.SURPRISE = 5;
  });

}).call(this);

//# sourceMappingURL=emotion.map
;
// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define('emotion/emotional.state.js',[], function() {
    return emo$.Engine.Emotion.EmotionalState = (function(_super) {
      var _emotions, _generalWeight, _previous, _valence;

      __extends(EmotionalState, _super);

      _generalWeight = 0.0;

      _valence = 0;

      _previous = null;

      _emotions = [];

      function EmotionalState(text, emotions, generalWeight, valence) {
        EmotionalState.__super__.constructor.call(this, text);
        _emotions = emotions || _emotions;
        _generalWeight = generalWeight;
        _valence = valence;
        if (_emotions.length === 0) {
          _emotions.push(new emo$.Engine.Emotion.Emotion(1.0, emo$.Engine.Emotion.Emotion.NEUTRAL));
        }
        this;
      }

      EmotionalState.prototype.getStrongestEmotion = function() {
        return _emotions[0];
      };

      EmotionalState.prototype.getFirstStrongestEmotions = function(stop) {
        var e, value, _i, _len;
        value = [];
        for (_i = 0, _len = _emotions.length; _i < _len; _i++) {
          e = _emotions[_i];
          if (stop <= 0) {
            break;
          }
          value.push(e);
          stop--;
        }
        return value;
      };

      EmotionalState.prototype.getHappiness = function() {
        var e, value, _i, _len;
        value = new Emotion(0.0, Emotion.HAPPINESS);
        for (_i = 0, _len = _emotions.length; _i < _len; _i++) {
          e = _emotions[_i];
          if (e.getType() === Emotion.HAPPINESS) {
            value = e;
          }
        }
        return value;
      };

      EmotionalState.prototype.getHappinessWeight = function() {
        return getHappiness().getWeight();
      };

      EmotionalState.prototype.getSadness = function() {
        var e, value, _i, _len;
        value = new Emotion(0.0, Emotion.SADNESS);
        for (_i = 0, _len = _emotions.length; _i < _len; _i++) {
          e = _emotions[_i];
          if (e.getType() === Emotion.SADNESS) {
            value = e;
          }
        }
        return value;
      };

      EmotionalState.prototype.getSadnessWeight = function() {
        return getSadness().getWeight();
      };

      EmotionalState.prototype.getFear = function() {
        var e, value, _i, _len;
        value = new Emotion(0.0, Emotion.FEAR);
        for (_i = 0, _len = _emotions.length; _i < _len; _i++) {
          e = _emotions[_i];
          if (e.getType() === Emotion.FEAR) {
            value = e;
          }
        }
        return value;
      };

      EmotionalState.prototype.getFearWeight = function() {
        return getFear().getWeight();
      };

      EmotionalState.prototype.getAnger = function() {
        var e, value, _i, _len;
        value = new Emotion(0.0, Emotion.ANGER);
        for (_i = 0, _len = _emotions.length; _i < _len; _i++) {
          e = _emotions[_i];
          if (e.getType() === Emotion.ANGER) {
            value = e;
          }
        }
        return value;
      };

      EmotionalState.prototype.getAngerWeight = function() {
        return getAnger().getWeight();
      };

      EmotionalState.prototype.getDisgust = function() {
        var e, value, _i, _len;
        value = new Emotion(0.0, Emotion.DISGUST);
        for (_i = 0, _len = _emotions.length; _i < _len; _i++) {
          e = _emotions[_i];
          if (e.getType() === Emotion.DISGUST) {
            value = e;
          }
        }
        return value;
      };

      EmotionalState.prototype.getDisgustWeight = function() {
        return getDisgust().getWeight();
      };

      EmotionalState.prototype.getSurprise = function() {
        var e, value, _i, _len;
        value = new Emotion(0.0, Emotion.SURPRISE);
        for (_i = 0, _len = _emotions.length; _i < _len; _i++) {
          e = _emotions[_i];
          if (e.getType() === Emotion.SURPRISE) {
            value = e;
          }
        }
        return value;
      };

      EmotionalState.prototype.getSurpriseWeight = function() {
        return getSurprise().getWeight();
      };

      EmotionalState.prototype.getPrevious = function() {
        return this.previous;
      };

      EmotionalState.prototype.setPrevious = function(_previous) {
        return this.previous = _previous;
      };

      EmotionalState.prototype.getValence = function() {
        return this.valence;
      };

      EmotionalState.prototype.getGeneralWeight = function() {
        return _generalWeight;
      };

      EmotionalState.prototype.toString = function() {
        var ret;
        return ret = "Text: " + text + "\nGeneral weight: " + _generalWeight + "\nValence: " + _valence + "\nHappiness weight: " + getHappinessWeight() + "\nSadness weight: " + getSadnessWeight() + "\nAnger weight: " + getAngerWeight() + "\nFear weight: " + getFearWeight() + "\nDisgust weight: " + getDisgustWeight() + "\nSurprise weight: " + getSurpriseWeight() + "\n";
      };

      return EmotionalState;

    })(emo$.Engine.SynesketchState);
  });

}).call(this);

//# sourceMappingURL=emotional.state.map
;
// Generated by CoffeeScript 1.7.1

/*
* Defines logic for transfering textual affect information -- emotional
* manifestations recognised in text -- into visual output.
*
* @author Uros Krcadinac email: uros@krcadinac.com
* @version 1.0
 */

(function() {
  define('emotion/empathy.scope.js',[], function() {
    return emo$.Engine.Emotion.EmpathyScope = (function() {
      var lexUtil;

      lexUtil = null;

      EmpathyScope.instance;

      function EmpathyScope() {
        lexUtil = emo$.Engine.Emotion.Helpers.Lexical.getInstance();
      }

      EmpathyScope.getInstance = function() {
        return EmpathyScope.instance != null ? EmpathyScope.instance : EmpathyScope.instance = new EmpathyScope();
      };

      EmpathyScope.prototype.feel = function(text) {
        var affectWords, capsLockCoef, emoWord, emoticonCoef, exclaminationQoef, hasNegation, modifierCoef, previousWord, ret, sentence, sentences, splittedWord, splittedWords, word, words, _i, _j, _k, _len, _len1, _len2;
        text = text.replace('\n', ' ');
        affectWords = [];
        sentences = emo$.Engine.Emotion.Helpers.Parsing.parseSentences(text);
        for (_i = 0, _len = sentences.length; _i < _len; _i++) {
          sentence = sentences[_i];
          hasNegation = emo$.Engine.Emotion.Helpers.Heuristics.hasNegation(sentence.toLowerCase());
          exclaminationQoef = emo$.Engine.Emotion.Helpers.Heuristics.computeExclaminationQoef(sentence.toLowerCase());
          splittedWords = emo$.Engine.Emotion.Helpers.Parsing.splitWords(sentence, ' ');
          previousWord = '';
          for (_j = 0, _len1 = splittedWords.length; _j < _len1; _j++) {
            splittedWord = splittedWords[_j];
            emoWord = lexUtil.getEmoticonAffectWord(splittedWord);
            if (emoWord !== null) {
              emoticonCoef = emo$.Engine.Emotion.Helpers.Heuristics.computeEmoticonCoef(splittedWord, emoWord);
              emoWord.adjustWeights(exclaminationQoef * emoticonCoef);
              affectWords.push(emoWord);
            } else {
              words = emo$.Engine.Emotion.Helpers.Parsing.parseWords(splittedWord);
            }
            for (_k = 0, _len2 = words.length; _k < _len2; _k++) {
              word = words[_k];
              emoWord = lexUtil.getAffectWord(word.toLowerCase());
            }
            if (emoWord !== null) {
              capsLockCoef = emo$.Engine.Emotion.Helpers.Heuristics.computeCapsLockQoef(word);
              modifierCoef = emo$.Engine.Emotion.Helpers.Heuristics.computeModifier(previousWord);
              if (hasNegation) {
                emoWord.flipValence();
              }
              emoWord.adjustWeights(exclaminationQoef * capsLockCoef * modifierCoef);
              affectWords.push(emoWord);
            }
            previousWord = word;
          }
        }
        return ret = this.createEmotionalState(text, affectWords);
      };

      EmpathyScope.prototype.createEmotionalState = function(text, affectWords) {
        var affectWord, angerWeight, disgustWeight, emotions, fearWeight, generalValence, generalWeight, happinessWeight, ret, sadnessWeight, surpriseWeight, valence, _i, _len;
        emotions = [];
        generalValence = 0;
        valence = 0.0;
        generalWeight = 0.0;
        happinessWeight = 0.0;
        sadnessWeight = 0.0;
        angerWeight = 0.0;
        fearWeight = 0.0;
        disgustWeight = 0.0;
        surpriseWeight = 0.0;
        for (_i = 0, _len = affectWords.length; _i < _len; _i++) {
          affectWord = affectWords[_i];
          valence += affectWord.getGeneralValence();
          if (affectWord.getGeneralWeight() > generalWeight) {
            generalWeight = affectWord.getGeneralWeight();
          }
          if (affectWord.getHappinessWeight() > happinessWeight) {
            happinessWeight = affectWord.getHappinessWeight();
          }
          if (affectWord.getSadnessWeight() > sadnessWeight) {
            sadnessWeight = affectWord.getSadnessWeight();
          }
          if (affectWord.getAngerWeight() > angerWeight) {
            angerWeight = affectWord.getAngerWeight();
          }
          if (affectWord.getFearWeight() > fearWeight) {
            fearWeight = affectWord.getFearWeight();
          }
          if (affectWord.getDisgustWeight() > disgustWeight) {
            disgustWeight = affectWord.getDisgustWeight();
          }
          if (affectWord.getSurpriseWeight() > surpriseWeight) {
            surpriseWeight = affectWord.getSurpriseWeight();
          }
        }
        if (valence > 0) {
          generalValence = 1;
        } else if (valence < 0) {
          generalValence = -1;
        }
        if (happinessWeight > 0) {
          emotions.push(new emo$.Engine.Emotion.Emotion(happinessWeight, emo$.Engine.Emotion.Emotion.HAPPINESS));
        }
        if (sadnessWeight > 0) {
          emotions.push(new emo$.Engine.Emotion.Emotion(sadnessWeight, emo$.Engine.Emotion.Emotion.SADNESS));
        }
        if (angerWeight > 0) {
          emotions.push(new emo$.Engine.Emotion.Emotion(angerWeight, emo$.Engine.Emotion.Emotion.ANGER));
        }
        if (fearWeight > 0) {
          emotions.push(new emo$.Engine.Emotion.Emotion(fearWeight, emo$.Engine.Emotion.Emotion.FEAR));
        }
        if (disgustWeight > 0) {
          emotions.push(new emo$.Engine.Emotion.Emotion(disgustWeight, emo$.Engine.Emotion.Emotion.DISGUST));
        }
        if (surpriseWeight > 0) {
          emotions.push(new emo$.Engine.Emotion.Emotion(surpriseWeight, emo$.Engine.Emotion.Emotion.SURPRISE));
        }
        if (emotions.length === 0) {
          emotions.push(new emo$.Engine.Emotion.Emotion((0.2 + generalWeight) / 1.2, emo$.Engine.Emotion.Emotion.NEUTRAL));
        }
        return ret = new emo$.Engine.Emotion.EmotionalState(text, emotions, generalWeight, generalValence);
      };

      return EmpathyScope;

    })();
  });

}).call(this);

//# sourceMappingURL=empathy.scope.map
;
// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define('emotion/synesthesiator.emotion.js',[], function() {
    return emo$.Engine.Emotion.SynesthesiatorEmotion = (function(_super) {
      var emotionalStates, empathyScope;

      __extends(SynesthesiatorEmotion, _super);

      emotionalStates = [];

      empathyScope = null;

      function SynesthesiatorEmotion(parentApplet) {
        SynesthesiatorEmotion.__super__.constructor.call(this, parentApplet);
        empathyScope = emo$.Engine.Emotion.EmpathyScope.getInstance();
      }

      SynesthesiatorEmotion.prototype.synesthesize = function(text) {
        var current;
        window.emotionalStates = emotionalStates;
        current = empathyScope.feel(text);
        if (emotionalStates.length !== 0) {
          current.setPrevious(emotionalStates[emotionalStates.length - 1]);
        }
        emotionalStates.push(current);
        return this.notifyPApplet(current);
      };

      return SynesthesiatorEmotion;

    })(emo$.Engine.Synesthesiator);
  });

}).call(this);

//# sourceMappingURL=synesthesiator.emotion.map
;
// Generated by CoffeeScript 1.7.1
(function() {
  emo$.Engine.Emotion = (function() {
    function Emotion() {}

    return Emotion;

  })();

  define('emotion/_emotion_.js',['./helpers/_helpers_.js', './affect.word.js', './emotion.js', './emotional.state.js', './empathy.scope.js', './synesthesiator.emotion.js'], function() {});

}).call(this);

//# sourceMappingURL=_emotion_.map
;
// Generated by CoffeeScript 1.7.1
(function() {
  define('synesketch.state.js',[], function() {
    return emo$.Engine.SynesketchState = (function() {
      function SynesketchState(text) {
        this.text = text;
      }

      SynesketchState.prototype.getText = function() {
        return this.text;
      };

      return SynesketchState;

    })();
  });

}).call(this);

//# sourceMappingURL=synesketch.state.map
;
// Generated by CoffeeScript 1.7.1
(function() {
  define('synesthesiator.js',[], function() {
    return emo$.Engine.Synesthesiator = (function() {
      function Synesthesiator(parent) {
        this.parent = parent;
        this.updateMethod = parent.synesketchUpdate;
        if (this.updateMethod == null) {
          this.updateMethod = function() {
            throw 'abstract method!';
            return console.log('this is update method');
          };
        }
      }

      Synesthesiator.prototype.notifyPApplet = function(state) {
        if (this.updateMethod !== null && !_.isUndefined(this.updateMethod)) {
          this.updateMethod.call(this.parent, state);
        }
        return this;
      };

      Synesthesiator.prototype.synesthesise = function(text) {
        throw 'abstract-has to be overriden!';
      };

      return Synesthesiator;

    })();
  });

}).call(this);

//# sourceMappingURL=synesthesiator.map
;
// Generated by CoffeeScript 1.7.1
(function() {
  emo$.Engine = (function() {
    function Engine() {}

    return Engine;

  })();

  define('_engine_.js',['./../../source/engine/utils/_utils_.js', './emotion/_emotion_.js', './synesketch.state.js', './synesthesiator.js'], function() {});

}).call(this);

//# sourceMappingURL=_engine_.map
;